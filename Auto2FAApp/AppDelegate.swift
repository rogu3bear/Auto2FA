import Cocoa\nimport Foundation\nimport SwiftUI // Needed if interacting with SwiftUI state later\nimport UserNotifications\n\n// AppDelegate to manage App Lifecycle hooks, including starting the XPC Listener.\nclass AppDelegate: NSObject, NSApplicationDelegate, UNUserNotificationCenterDelegate {\n\n    private var listener: NSXPCListener?\n    // Hold a strong reference to the XPCManager instance that acts as the exported object.\n    private let xpcManager = XPCManager()\n\n    func applicationDidFinishLaunching(_ notification: Notification) {\n        print(\"App Did Finish Launching - Setting up XPC Listener.\")\n        setupXPCListener()\n        setupNotifications()\n\n         // Perform any other initial setup tasks here\n         // e.g., Check if keychain items exist for accounts loaded by AppState\n    }\n\n     func applicationWillTerminate(_ notification: Notification) {\n         // Clean up resources if necessary.\n         print(\"App Will Terminate - Invalidating XPC Listener.\")\n         listener?.invalidate() // Stop listening\n     }\n\n    // --- Notification Setup ---\n    private func setupNotifications() {\n        let center = UNUserNotificationCenter.current()\n        center.delegate = self\n         \n        center.requestAuthorization(options: [.alert, .sound]) { granted, error in\n            if granted {\n                print(\"Notification authorization granted\")\n            } else if let error = error {\n                print(\"Notification authorization error: \\(error.localizedDescription)\")\n            }\n        }\n    }\n\n    // UNUserNotificationCenterDelegate\n    func userNotificationCenter(_ center: UNUserNotificationCenter,\n                              willPresent notification: UNNotification,\n                              withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {\n        completionHandler([.banner, .sound])\n    }\n\n    // --- XPC Setup ---\n    private func setupXPCListener() {\n        // The listener for the main application service.\n        // It will create connections and vend instances of our XPCManager object.\n        let listener = NSXPCListener.service()\n        listener.delegate = xpcManager // Assign the manager instance as the delegate\n        self.listener = listener\n        listener.resume() // Start listening for incoming connections\n        print(\"XPC Listener (\(XPCServiceKeys.serviceName)) is active and listening.\")\n    }\n}\n\n// MARK: - XPC Connection Manager (Delegate & Exported Object)\n\n// This class handles incoming XPC connections and implements the AppXPCProtocol.\nclass XPCManager: NSObject, NSXPCListenerDelegate, AppXPCProtocol {\n\n    // MARK: - Error Handling & Notifications\n\n    private func showErrorNotification(title: String, body: String) {\n        let content = UNMutableNotificationContent()\n        content.title = title\n        content.body = body\n        content.sound = .default\n         \n        let request = UNNotificationRequest(identifier: UUID().uuidString,\n                                          content: content,\n                                          trigger: nil)\n         \n        UNUserNotificationCenter.current().add(request) { error in\n            if let error = error {\n                print(\"Error showing notification: \\(error.localizedDescription)\")\n            }\n        }\n    }\n\n    private func handleAuthenticationError(_ error: Error, accountId: UUID) {\n        let title = \"Authentication Failed\"\n        let body: String\n         \n        switch error {\n        case let keychainError as KeychainError {\n            switch keychainError {\n            case .authenticationFailed: \n                body = \"Touch ID/Passcode authentication failed. Please try again.\"\n            case .itemNotFound: \n                body = \"No credentials found for this account. Please add them in the app.\"\n            case .unhandledError: \n                body = \"An unexpected error occurred while accessing credentials.\"\n            }\n        default: \n            body = \"An error occurred while accessing credentials: \\(error.localizedDescription)\"\n        }\n         \n        showErrorNotification(title: title, body: body)\n    }\n\n    private func handleMappingError(_ error: Error) {\n        let title = \"Domain Mapping Error\"\n        let body: String\n         \n        switch error {\n        case let mappingError as MappingError {\n            switch mappingError {\n            case .noMappingFound: \n                body = \"No account mapping found for this domain. Please add a mapping in the app.\"\n            case .multipleMappingsFound: \n                body = \"Multiple accounts match this domain. Please select one manually.\"\n            }\n        default: \n            body = \"An error occurred while checking domain mappings: \\(error.localizedDescription)\"\n        }\n         \n        showErrorNotification(title: title, body: body)\n    }\n\n    // MARK: - NSXPCListenerDelegate\n\n    // This method is called by the NSXPCListener when a new connection arrives\n    // from a client (e.g., the Safari Extension).\n    func listener(_ listener: NSXPCListener, shouldAcceptNewConnection newConnection: NSXPCConnection) -> Bool {\n        print(\"XPC Listener received incoming connection request.\")\n\n        // 1. Security Validation: Verify the connecting client.\n        guard validateConnection(newConnection) else {\n            print(\"XPC Connection validation failed. Rejecting connection.\")\n            showErrorNotification(\n                title: \"Security Error\",\n                body: \"Connection from Safari extension was rejected due to invalid signature.\"\n            )\n            return false // Reject the connection if validation fails\n        }\n        print(\"XPC Connection validated successfully.\")\n\n        // 2. Configure the connection:\n        //    - Set the interface the exported object conforms to.\n        //    - Set the interface the remote object (client proxy) is expected to conform to (if any).\n        newConnection.exportedInterface = NSXPCInterface(with: AppXPCProtocol.self)\n        // If the extension needs to call back to the app, define a protocol and set remoteObjectInterface\n        // newConnection.remoteObjectInterface = NSXPCInterface(with: ExtensionCallbackProtocol.self)\n\n        //    - Set the object that will handle the incoming messages.\n        newConnection.exportedObject = self // This XPCManager instance will handle the calls.\n\n        // 3. Set handlers for interruption (process crash) and invalidation (disconnect).\n        newConnection.interruptionHandler = {\n            // This block is called if the connection process exits unexpectedly.\n            print(\"XPC Connection Interrupted (Client likely crashed or was terminated).\")\n            self.showErrorNotification(\n                title: \"Connection Lost\",\n                body: \"Connection to Safari extension was lost. Please reload the extension.\"\n            )\n        }\n        newConnection.invalidationHandler = {\n            // This block is called when the connection is explicitly invalidated (e.g., client disconnects).\n            print(\"XPC Connection Invalidated (Client disconnected gracefully).\")\n        }\n\n        // 4. Resume the connection to allow it to start receiving messages.\n        newConnection.resume()\n        print(\"XPC Connection configured and resumed. Ready for requests.\")\n\n        // 5. Return true to accept the connection.\n        return true\n    }\n\n    // MARK: - Connection Validation\n\n    private func validateConnection(_ connection: NSXPCConnection) -> Bool {\n        do {\n            // Obtain the audit token from the connection\n            var auditToken = connection.auditToken\n\n            // Create a SecCode object representing the connecting client process\n            var clientCode: SecCode?\n            let status = SecCodeCopyGuestWithAttributes(nil, [kSecGuestAttributeAudit : NSData(bytes: &auditToken, length: MemoryLayout<audit_token_t>.size)] as CFDictionary, [], &clientCode)\n\n            guard status == errSecSuccess, let clientCode = clientCode else {\n                print(\"XPC Validation Error: Could not get SecCode for client. Status: \\(status)\")\n                return false\n            }\n\n            // Define the requirement: Must be signed by the same team and match the expected bundle ID.\n            // IMPORTANT: Ensure XPCServiceKeys.allowedClientBundleID is the *exact* Bundle ID of your Safari Extension.\n            let requirementString = \"anchor apple generic and identifier \\\"\\(XPCServiceKeys.allowedClientBundleID)\\\" and certificate leaf[subject.OU] = \\(getDevelopmentTeamIdentifier())\"\n            \n            // Alternative/Simpler (if just checking bundle ID is enough initially, less secure):\n            // let requirementString = \"identifier \\(XPCServiceKeys.allowedClientBundleID)\"\n\n            var requirement: SecRequirement?\n            guard SecRequirementCreateWithString(requirementString as CFString, [], &requirement) == errSecSuccess, let requirement = requirement else {\n                 print(\"XPC Validation Error: Could not create SecRequirement from string: \\(requirementString)\")\n                return false\n            }\n\n            // Validate the client code against the requirement.\n            let validationStatus = SecCodeCheckValidity(clientCode, [], requirement)\n            if validationStatus == errSecSuccess {\n                print(\"XPC Client validation successful: Identifier=\\(XPCServiceKeys.allowedClientBundleID), TeamID=\\(getDevelopmentTeamIdentifier() ?? \"Unknown\")\")\n                return true\n            } else {\n                print(\"XPC Client validation failed: Status \\(validationStatus). Client does not meet requirement: \\(requirementString)\")\n                // Log details about the client for debugging if needed\n                var clientInfo: CFDictionary?\n                if SecCodeCopySigningInformation(clientCode, [.signingIdentifier, .teamIdentifier], &clientInfo) == errSecSuccess {\n                    print(\"Actual client info: \\(clientInfo as? [String: Any] ?? [:])\")\n                }\n                return false\n            }\n        } catch {\n            print(\"XPC Validation Error: Unexpected exception during validation: \\(error)\")\n            return false\n        }\n    }\n    \n    /// Helper function to get the Team Identifier from the main app's bundle.\n    /// Assumes the main app and extension share the same Team ID.\n    private func getDevelopmentTeamIdentifier() -> String? {\n        var teamID: String? = nil\n        var appCode: SecCode?\n        \n        // Get SecCode for the current app process\n        if SecCodeCopySelf([], &appCode) == errSecSuccess, let appCode = appCode {\n            var appInfo: CFDictionary?\n            // Copy signing info, specifically requesting the Team Identifier\n            if SecCodeCopySigningInformation(appCode, [.teamIdentifier], &appInfo) == errSecSuccess,\n               let infoDict = appInfo as? [String: Any],\n               let id = infoDict[kSecCodeInfoTeamIdentifier as String] as? String {\n                teamID = id\n            }\n        }\n        if teamID == nil {\n            print(\"Warning: Could not retrieve Team Identifier for validation. Ensure app is signed.\")\n        }\n        return teamID\n    }\n\n    // MARK: - AppXPCProtocol Implementation\n\n    // This method is called remotely by the Safari Extension via the XPC connection.\n    func getCredentials(forAccountID accountID: UUID, completionHandler: @escaping (String?, String?, String?, String?, String?) -> Void) {\n        print(\"XPC Service: Received request for credentials for Account ID: \\(accountID)\")\n        \n        // Perform the operation on a background thread to avoid blocking the XPC connection thread,\n        // especially since Keychain access can involve UI (authentication prompts).\n        DispatchQueue.global(qos: .userInitiated).async {\n            var result: (String?, String?, String?, String?, String?) = (nil, nil, nil, nil, \"Unknown error occurred.\")\n            do {\n                // Attempt to get credentials from Keychain. This will trigger Touch ID/Passcode if needed.\n                let credentials = try KeychainManager.shared.getCredentials(accountId: accountID)\n                print(\"XPC Service: Successfully retrieved credentials for \\(accountID) from Keychain.\")\n                // Prepare the successful result tuple\n                result = (\n                    credentials.username,\n                    credentials.password,\n                    credentials.authMethodRawValue,\n                    credentials.methodDetails,\n                    nil // No error\n                )\n            } catch let error as KeychainError {\n                print(\"XPC Service: Keychain error for \\(accountID): \\(error.localizedDescription)\")\n                self.handleAuthenticationError(error, accountId: accountID)\n                result = (nil, nil, nil, nil, error.localizedDescription)\n            } catch {\n                print(\"XPC Service: Unexpected error getting credentials for \\(accountID): \\(error)\")\n                self.handleAuthenticationError(error, accountId: accountID)\n                result = (nil, nil, nil, nil, error.localizedDescription)\n            }\n            \n            // Send the result back to the client on the main thread (common practice for completion handlers)\n            DispatchQueue.main.async {\n                 completionHandler(result.0, result.1, result.2, result.3, result.4)\n                 print(\"XPC Service: Sent response back to client for account \\(accountID).\")\n            }\n        }\n    }\n    
    func getAllMappings(completionHandler: @escaping (Data?, String?) -> Void) {
        print("XPC Service: Received request for all domain mappings.")
        
        // Fetch mappings from the authoritative source (SharedDataManager)
        let mappings = SharedDataManager.shared.loadDomainMappings()
        
        do {
            // Encode the array of DomainMapping objects into Data
            let data = try JSONEncoder().encode(mappings)
            print("XPC Service: Successfully encoded \(mappings.count) mappings. Sending data.")
            completionHandler(data, nil) // Send data, no error
        } catch {
            print("XPC Service: Error encoding domain mappings: \(error.localizedDescription)")
            self.showErrorNotification(
                title: "Mapping Error",
                body: "Failed to retrieve domain mappings: \(error.localizedDescription)"
            )
            completionHandler(nil, "Error encoding domain mappings: \(error.localizedDescription)")
        }
    }
} 

// MARK: - Error Types

enum MappingError: Error {
    case noMappingFound
    case multipleMappingsFound
}

enum KeychainError: Error {
    case authenticationFailed
    case itemNotFound
    case unhandledError(String)
} 